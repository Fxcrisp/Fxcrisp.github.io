<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue尚硅谷笔记</title>
      <link href="/2023/09/03/Vue%E5%B0%9A%E7%A1%85%E8%B0%B7%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/09/03/Vue%E5%B0%9A%E7%A1%85%E8%B0%B7%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><a id="article_top"></a>本篇是上传的尚硅谷的笔记，方便随时阅读学习。</p><h1 id="Vue3快速上手"><a href="#Vue3快速上手" class="headerlink" title="Vue3快速上手"></a>Vue3快速上手</h1><img src="https://user-images.githubusercontent.com/499550/93624428-53932780-f9ae-11ea-8d16-af949e16a09f.png" style="width:200px" /><h2 id="1-Vue3简介"><a href="#1-Vue3简介" class="headerlink" title="1.Vue3简介"></a>1.Vue3简介</h2><ul><li>2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）</li><li>耗时2年多、<a href="https://github.com/vuejs/vue-next/graphs/commit-activity">2600+次提交</a>、<a href="https://github.com/vuejs/rfcs/tree/master/active-rfcs">30+个RFC</a>、<a href="https://github.com/vuejs/vue-next/pulls?q=is:pr+is:merged+-author:app/dependabot-preview+">600+次PR</a>、<a href="https://github.com/vuejs/vue-next/graphs/contributors">99位贡献者</a> </li><li>github上的tags地址：<a href="https://github.com/vuejs/vue-next/releases/tag/v3.0.0">https://github.com/vuejs/vue-next/releases/tag/v3.0.0</a></li></ul><h2 id="2-Vue3带来了什么"><a href="#2-Vue3带来了什么" class="headerlink" title="2.Vue3带来了什么"></a>2.Vue3带来了什么</h2><h3 id="1-性能的提升"><a href="#1-性能的提升" class="headerlink" title="1.性能的提升"></a>1.性能的提升</h3><ul><li><p>打包大小减少41%</p></li><li><p>初次渲染快55%, 更新渲染快133%</p></li><li><p>内存减少54%</p><p>……</p></li></ul><h3 id="2-源码的升级"><a href="#2-源码的升级" class="headerlink" title="2.源码的升级"></a>2.源码的升级</h3><ul><li><p>使用Proxy代替defineProperty实现响应式</p></li><li><p>重写虚拟DOM的实现和Tree-Shaking</p><p>……</p></li></ul><h3 id="3-拥抱TypeScript"><a href="#3-拥抱TypeScript" class="headerlink" title="3.拥抱TypeScript"></a>3.拥抱TypeScript</h3><ul><li>Vue3可以更好的支持TypeScript</li></ul><h3 id="4-新的特性"><a href="#4-新的特性" class="headerlink" title="4.新的特性"></a>4.新的特性</h3><ol><li><p>Composition API（组合API）</p><ul><li>setup配置</li><li>ref与reactive</li><li>watch与watchEffect</li><li>provide与inject</li><li>……</li></ul></li><li><p>新的内置组件</p><ul><li>Fragment </li><li>Teleport</li><li>Suspense</li></ul></li><li><p>其他改变</p><ul><li>新的生命周期钩子</li><li>data 选项应始终被声明为一个函数</li><li>移除keyCode支持作为 v-on 的修饰符</li><li>……</li></ul></li></ol><h1 id="一、创建Vue3-0工程"><a href="#一、创建Vue3-0工程" class="headerlink" title="一、创建Vue3.0工程"></a>一、创建Vue3.0工程</h1><h2 id="1-使用-vue-cli-创建"><a href="#1-使用-vue-cli-创建" class="headerlink" title="1.使用 vue-cli 创建"></a>1.使用 vue-cli 创建</h2><p>官方文档：<a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create</a></p><pre><code class="bash">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上vue --version## 安装或者升级你的@vue/clinpm install -g @vue/cli## 创建vue create vue_test## 启动cd vue_testnpm run serve</code></pre><h2 id="2-使用-vite-创建"><a href="#2-使用-vite-创建" class="headerlink" title="2.使用 vite 创建"></a>2.使用 vite 创建</h2><p>官方文档：<a href="https://v3.cn.vuejs.org/guide/installation.html#vite">https://v3.cn.vuejs.org/guide/installation.html#vite</a></p><p>vite官网：<a href="https://vitejs.cn/">https://vitejs.cn</a></p><ul><li>什么是vite？—— 新一代前端构建工具。</li><li>优势如下：<ul><li>开发环境中，无需打包操作，可快速的冷启动。</li><li>轻量快速的热重载（HMR）。</li><li>真正的按需编译，不再等待整个应用编译完成。</li></ul></li><li>传统构建 与 vite构建对比图</li></ul><p><img src="https://cn.vitejs.dev/assets/bundler.37740380.png" style="width:500px;height:280px;float:left" /><img src="https://cn.vitejs.dev/assets/esm.3070012d.png" style="width:480px;height:280px" /></p><pre><code class="bash">## 创建工程npm init vite-app &lt;project-name&gt;## 进入工程目录cd &lt;project-name&gt;## 安装依赖npm install## 运行npm run dev</code></pre><h1 id="二、常用-Composition-API"><a href="#二、常用-Composition-API" class="headerlink" title="二、常用 Composition API"></a>二、常用 Composition API</h1><p>官方文档: <a href="https://v3.cn.vuejs.org/guide/composition-api-introduction.html">https://v3.cn.vuejs.org/guide/composition-api-introduction.html</a></p><h2 id="1-拉开序幕的setup"><a href="#1-拉开序幕的setup" class="headerlink" title="1.拉开序幕的setup"></a>1.拉开序幕的setup</h2><ol><li>理解：Vue3.0中一个新的配置项，值为一个函数。</li><li>setup是所有<strong style="color:#DD5145">Composition API（组合API）</strong><i style="color:gray;font-weight:bold">“ 表演的舞台 ”</i>。</li><li>组件中所用到的：数据、方法等等，均要配置在setup中。</li><li>setup函数的两种返回值：<ol><li>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）</li><li><span style="color:#aad">若返回一个渲染函数：则可以自定义渲染内容。（了解）</span></li></ol></li><li>注意点：<ol><li>尽量不要与Vue2.x配置混用<ul><li>Vue2.x配置（data、methos、computed…）中<strong style="color:#DD5145">可以访问到</strong>setup中的属性、方法。</li><li>但在setup中<strong style="color:#DD5145">不能访问到</strong>Vue2.x配置（data、methos、computed…）。</li><li>如果有重名, setup优先。</li></ul></li><li>setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）</li></ol></li></ol><h2 id="2-ref函数"><a href="#2-ref函数" class="headerlink" title="2.ref函数"></a>2.ref函数</h2><ul><li>作用: 定义一个响应式的数据</li><li>语法: <code>const xxx = ref(initValue)</code> <ul><li>创建一个包含响应式数据的<strong style="color:#DD5145">引用对象（reference对象，简称ref对象）</strong>。</li><li>JS中操作数据： <code>xxx.value</code></li><li>模板中读取数据: 不需要.value，直接：<code>&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;</code></li></ul></li><li>备注：<ul><li>接收的数据可以是：基本类型、也可以是对象类型。</li><li>基本类型的数据：响应式依然是靠<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>完成的。</li><li>对象类型的数据：内部 <i style="color:gray;font-weight:bold">“ 求助 ”</i> 了Vue3.0中的一个新函数—— <code>reactive</code>函数。</li></ul></li></ul><h2 id="3-reactive函数"><a href="#3-reactive函数" class="headerlink" title="3.reactive函数"></a>3.reactive函数</h2><ul><li>作用: 定义一个<strong style="color:#DD5145">对象类型</strong>的响应式数据（基本类型不要用它，要用<code>ref</code>函数）</li><li>语法：<code>const 代理对象= reactive(源对象)</code>接收一个对象（或数组），返回一个<strong style="color:#DD5145">代理对象（Proxy的实例对象，简称proxy对象）</strong></li><li>reactive定义的响应式数据是“深层次的”。</li><li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</li></ul><h2 id="4-Vue3-0中的响应式原理"><a href="#4-Vue3-0中的响应式原理" class="headerlink" title="4.Vue3.0中的响应式原理"></a>4.Vue3.0中的响应式原理</h2><h3 id="vue2-x的响应式"><a href="#vue2-x的响应式" class="headerlink" title="vue2.x的响应式"></a>vue2.x的响应式</h3><ul><li><p>实现原理：</p><ul><li><p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p></li><li><p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p><pre><code class="js">Object.defineProperty(data, &#39;count&#39;, &#123;    get () &#123;&#125;,     set () &#123;&#125;&#125;)</code></pre></li></ul></li><li><p>存在问题：</p><ul><li>新增属性、删除属性, 界面不会更新。</li><li>直接通过下标修改数组, 界面不会自动更新。</li></ul></li></ul><h3 id="Vue3-0的响应式"><a href="#Vue3-0的响应式" class="headerlink" title="Vue3.0的响应式"></a>Vue3.0的响应式</h3><ul><li>实现原理: <ul><li>通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</li><li>通过Reflect（反射）:  对源对象的属性进行操作。</li><li>MDN文档中描述的Proxy与Reflect：<ul><li><p>Proxy：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p></li><li><p>Reflect：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p><pre><code class="js">new Proxy(data, &#123;    // 拦截读取属性值    get (target, prop) &#123;        return Reflect.get(target, prop)    &#125;,    // 拦截设置属性值或添加新属性    set (target, prop, value) &#123;        return Reflect.set(target, prop, value)    &#125;,    // 拦截删除属性    deleteProperty (target, prop) &#123;        return Reflect.deleteProperty(target, prop)    &#125;&#125;)proxy.name = &#39;tom&#39;   </code></pre></li></ul></li></ul></li></ul><h2 id="5-reactive对比ref"><a href="#5-reactive对比ref" class="headerlink" title="5.reactive对比ref"></a>5.reactive对比ref</h2><ul><li>从定义数据角度对比：<ul><li>ref用来定义：<strong style="color:#DD5145">基本类型数据</strong>。</li><li>reactive用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。</li><li>备注：ref也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong style="color:#DD5145">代理对象</strong>。</li></ul></li><li>从原理角度对比：<ul><li>ref通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li><li>reactive通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作<strong style="color:orange">源对象</strong>内部的数据。</li></ul></li><li>从使用角度对比：<ul><li>ref定义的数据：操作数据<strong style="color:#DD5145">需要</strong><code>.value</code>，读取数据时模板中直接读取<strong style="color:#DD5145">不需要</strong><code>.value</code>。</li><li>reactive定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong><code>.value</code>。</li></ul></li></ul><h2 id="6-setup的两个注意点"><a href="#6-setup的两个注意点" class="headerlink" title="6.setup的两个注意点"></a>6.setup的两个注意点</h2><ul><li><p>setup执行的时机</p><ul><li>在beforeCreate之前执行一次，this是undefined。</li></ul></li><li><p>setup的参数</p><ul><li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</li><li>context：上下文对象<ul><li>attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 <code>this.$attrs</code>。</li><li>slots: 收到的插槽内容, 相当于 <code>this.$slots</code>。</li><li>emit: 分发自定义事件的函数, 相当于 <code>this.$emit</code>。</li></ul></li></ul></li></ul><h2 id="7-计算属性与监视"><a href="#7-计算属性与监视" class="headerlink" title="7.计算属性与监视"></a>7.计算属性与监视</h2><h3 id="1-computed函数"><a href="#1-computed函数" class="headerlink" title="1.computed函数"></a>1.computed函数</h3><ul><li><p>与Vue2.x中computed配置功能一致</p></li><li><p>写法</p><pre><code class="js">import &#123;computed&#125; from &#39;vue&#39;setup()&#123;    ...    //计算属性——简写    let fullName = computed(()=&gt;&#123;        return person.firstName + &#39;-&#39; + person.lastName    &#125;)    //计算属性——完整    let fullName = computed(&#123;        get()&#123;            return person.firstName + &#39;-&#39; + person.lastName        &#125;,        set(value)&#123;            const nameArr = value.split(&#39;-&#39;)            person.firstName = nameArr[0]            person.lastName = nameArr[1]        &#125;    &#125;)&#125;</code></pre></li></ul><h3 id="2-watch函数"><a href="#2-watch函数" class="headerlink" title="2.watch函数"></a>2.watch函数</h3><ul><li><p>与Vue2.x中watch配置功能一致</p></li><li><p>两个小“坑”：</p><ul><li>监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。</li><li>监视reactive定义的响应式数据中某个属性时：deep配置有效。</li></ul><pre><code class="js">//情况一：监视ref定义的响应式数据watch(sum,(newValue,oldValue)=&gt;&#123;    console.log(&#39;sum变化了&#39;,newValue,oldValue)&#125;,&#123;immediate:true&#125;)//情况二：监视多个ref定义的响应式数据watch([sum,msg],(newValue,oldValue)=&gt;&#123;    console.log(&#39;sum或msg变化了&#39;,newValue,oldValue)&#125;) /* 情况三：监视reactive定义的响应式数据            若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！            若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 */watch(person,(newValue,oldValue)=&gt;&#123;    console.log(&#39;person变化了&#39;,newValue,oldValue)&#125;,&#123;immediate:true,deep:false&#125;) //此处的deep配置不再奏效//情况四：监视reactive定义的响应式数据中的某个属性watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;    console.log(&#39;person的job变化了&#39;,newValue,oldValue)&#125;,&#123;immediate:true,deep:true&#125;) //情况五：监视reactive定义的响应式数据中的某些属性watch([()=&gt;person.job,()=&gt;person.name],(newValue,oldValue)=&gt;&#123;    console.log(&#39;person的job变化了&#39;,newValue,oldValue)&#125;,&#123;immediate:true,deep:true&#125;)//特殊情况watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;    console.log(&#39;person的job变化了&#39;,newValue,oldValue)&#125;,&#123;deep:true&#125;) //此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效</code></pre></li></ul><h3 id="3-watchEffect函数"><a href="#3-watchEffect函数" class="headerlink" title="3.watchEffect函数"></a>3.watchEffect函数</h3><ul><li><p>watch的套路是：既要指明监视的属性，也要指明监视的回调。</p></li><li><p>watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。</p></li><li><p>watchEffect有点像computed：</p><ul><li>但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</li><li>而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</li></ul><pre><code class="js">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。watchEffect(()=&gt;&#123;    const x1 = sum.value    const x2 = person.age    console.log(&#39;watchEffect配置的回调执行了&#39;)&#125;)</code></pre></li></ul><h2 id="8-生命周期"><a href="#8-生命周期" class="headerlink" title="8.生命周期"></a>8.生命周期</h2><div style="border:1px solid black;width:380px;float:left;margin-right:20px;"><strong>vue2.x的生命周期</strong><img src="https://cn.vuejs.org/images/lifecycle.png" alt="lifecycle_2" style="zoom:33%;width:1200px" /></div><div style="border:1px solid black;width:510px;height:985px;float:left"><strong>vue3.0的生命周期</strong><img src="https://v3.cn.vuejs.org/images/lifecycle.svg" alt="lifecycle_2" style="zoom:33%;width:2500px" /></div><p>1</p><ul><li>Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：<ul><li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li><li><code>destroyed</code>改名为 <code>unmounted</code></li></ul></li><li>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：<ul><li><code>beforeCreate</code>&#x3D;&#x3D;&#x3D;&gt;<code>setup()</code></li><li><code>created</code>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>setup()</code></li><li><code>beforeMount</code> &#x3D;&#x3D;&#x3D;&gt;<code>onBeforeMount</code></li><li><code>mounted</code>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>onMounted</code></li><li><code>beforeUpdate</code>&#x3D;&#x3D;&#x3D;&gt;<code>onBeforeUpdate</code></li><li><code>updated</code> &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>onUpdated</code></li><li><code>beforeUnmount</code> &#x3D;&#x3D;&gt;<code>onBeforeUnmount</code></li><li><code>unmounted</code> &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>onUnmounted</code></li></ul></li></ul><h2 id="9-自定义hook函数"><a href="#9-自定义hook函数" class="headerlink" title="9.自定义hook函数"></a>9.自定义hook函数</h2><ul><li><p>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。</p></li><li><p>类似于vue2.x中的mixin。</p></li><li><p>自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。</p></li></ul><h2 id="10-toRef"><a href="#10-toRef" class="headerlink" title="10.toRef"></a>10.toRef</h2><ul><li><p>作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。</p></li><li><p>语法：<code>const name = toRef(person,&#39;name&#39;)</code></p></li><li><p>应用:   要将响应式对象中的某个属性单独提供给外部使用时。</p></li><li><p>扩展：<code>toRefs</code> 与<code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code></p></li></ul><h1 id="三、其它-Composition-API"><a href="#三、其它-Composition-API" class="headerlink" title="三、其它 Composition API"></a>三、其它 Composition API</h1><h2 id="1-shallowReactive-与-shallowRef"><a href="#1-shallowReactive-与-shallowRef" class="headerlink" title="1.shallowReactive 与 shallowRef"></a>1.shallowReactive 与 shallowRef</h2><ul><li><p>shallowReactive：只处理对象最外层属性的响应式（浅响应式）。</p></li><li><p>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</p></li><li><p>什么时候使用?</p><ul><li>如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 &#x3D;&#x3D;&#x3D;&gt; shallowReactive。</li><li>如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 &#x3D;&#x3D;&#x3D;&gt; shallowRef。</li></ul></li></ul><h2 id="2-readonly-与-shallowReadonly"><a href="#2-readonly-与-shallowReadonly" class="headerlink" title="2.readonly 与 shallowReadonly"></a>2.readonly 与 shallowReadonly</h2><ul><li>readonly: 让一个响应式数据变为只读的（深只读）。</li><li>shallowReadonly：让一个响应式数据变为只读的（浅只读）。</li><li>应用场景: 不希望数据被修改时。</li></ul><h2 id="3-toRaw-与-markRaw"><a href="#3-toRaw-与-markRaw" class="headerlink" title="3.toRaw 与 markRaw"></a>3.toRaw 与 markRaw</h2><ul><li>toRaw：<ul><li>作用：将一个由<code>reactive</code>生成的<strong style="color:orange">响应式对象</strong>转为<strong style="color:orange">普通对象</strong>。</li><li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li></ul></li><li>markRaw：<ul><li>作用：标记一个对象，使其永远不会再成为响应式对象。</li><li>应用场景:<ol><li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li><li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li></ol></li></ul></li></ul><h2 id="4-customRef"><a href="#4-customRef" class="headerlink" title="4.customRef"></a>4.customRef</h2><ul><li><p>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。</p></li><li><p>实现防抖效果：</p><pre><code class="vue">&lt;template&gt;    &lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt;    &lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script&gt;    import &#123;ref,customRef&#125; from &#39;vue&#39;    export default &#123;        name:&#39;Demo&#39;,        setup()&#123;            // let keyword = ref(&#39;hello&#39;) //使用Vue准备好的内置ref            //自定义一个myRef            function myRef(value,delay)&#123;                let timer                //通过customRef去实现自定义                return customRef((track,trigger)=&gt;&#123;                    return&#123;                        get()&#123;                            track() //告诉Vue这个value值是需要被“追踪”的                            return value                        &#125;,                        set(newValue)&#123;                            clearTimeout(timer)                            timer = setTimeout(()=&gt;&#123;                                value = newValue                                trigger() //告诉Vue去更新界面                            &#125;,delay)                        &#125;                    &#125;                &#125;)            &#125;            let keyword = myRef(&#39;hello&#39;,500) //使用程序员自定义的ref            return &#123;                keyword            &#125;        &#125;    &#125;&lt;/script&gt;</code></pre></li></ul><h2 id="5-provide-与-inject"><a href="#5-provide-与-inject" class="headerlink" title="5.provide 与 inject"></a>5.provide 与 inject</h2><img src="https://v3.cn.vuejs.org/images/components_provide.png" style="width:300px" /><ul><li><p>作用：实现<strong style="color:#DD5145">祖与后代组件间</strong>通信</p></li><li><p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p></li><li><p>具体写法：</p><ol><li><p>祖组件中：</p><pre><code class="js">setup()&#123;    ......    let car = reactive(&#123;name:&#39;奔驰&#39;,price:&#39;40万&#39;&#125;)    provide(&#39;car&#39;,car)    ......&#125;</code></pre></li><li><p>后代组件中：</p><pre><code class="js">setup(props,context)&#123;    ......    const car = inject(&#39;car&#39;)    return &#123;car&#125;    ......&#125;</code></pre></li></ol></li></ul><h2 id="6-响应式数据的判断"><a href="#6-响应式数据的判断" class="headerlink" title="6.响应式数据的判断"></a>6.响应式数据的判断</h2><ul><li>isRef: 检查一个值是否为一个 ref 对象</li><li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li><li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li><li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li></ul><h1 id="四、Composition-API-的优势"><a href="#四、Composition-API-的优势" class="headerlink" title="四、Composition API 的优势"></a>四、Composition API 的优势</h1><h2 id="1-Options-API-存在的问题"><a href="#1-Options-API-存在的问题" class="headerlink" title="1.Options API 存在的问题"></a>1.Options API 存在的问题</h2><p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。</p><div style="width:600px;height:370px;overflow:hidden;float:left">    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84e4e2c02424d9a99862ade0a2e4114~tplv-k3u1fbpfcp-watermark.image" style="width:600px;float:left" /></div><div style="width:300px;height:370px;overflow:hidden;float:left">    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.image" style="zoom:50%;width:560px;left" /> </div><h2 id="2-Composition-API-的优势"><a href="#2-Composition-API-的优势" class="headerlink" title="2.Composition API 的优势"></a>2.Composition API 的优势</h2><p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p><div style="width:500px;height:340px;overflow:hidden;float:left">    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0be8211fc54b6c941c036791ba4efe~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/></div><div style="width:430px;height:340px;overflow:hidden;float:left">    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc55165c0e34069a75fe36f8712eb80~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/></div><h1 id="五、新的组件"><a href="#五、新的组件" class="headerlink" title="五、新的组件"></a>五、新的组件</h1><h2 id="1-Fragment"><a href="#1-Fragment" class="headerlink" title="1.Fragment"></a>1.Fragment</h2><ul><li>在Vue2中: 组件必须有一个根标签</li><li>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</li><li>好处: 减少标签层级, 减小内存占用</li></ul><h2 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2.Teleport"></a>2.Teleport</h2><ul><li><p>什么是Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong style="color:#DD5145">组件html结构</strong>移动到指定位置的技术。</p><pre><code class="vue">&lt;teleport to=&quot;移动位置&quot;&gt;    &lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;        &lt;div class=&quot;dialog&quot;&gt;            &lt;h3&gt;我是一个弹窗&lt;/h3&gt;            &lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/teleport&gt;</code></pre></li></ul><h2 id="3-Suspense"><a href="#3-Suspense" class="headerlink" title="3.Suspense"></a>3.Suspense</h2><ul><li><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p></li><li><p>使用步骤：</p><ul><li><p>异步引入组件</p><pre><code class="js">import &#123;defineAsyncComponent&#125; from &#39;vue&#39;const Child = defineAsyncComponent(()=&gt;import(&#39;./components/Child.vue&#39;))</code></pre></li><li><p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></p><pre><code class="vue">&lt;template&gt;    &lt;div class=&quot;app&quot;&gt;        &lt;h3&gt;我是App组件&lt;/h3&gt;        &lt;Suspense&gt;            &lt;template v-slot:default&gt;                &lt;Child/&gt;            &lt;/template&gt;            &lt;template v-slot:fallback&gt;                &lt;h3&gt;加载中.....&lt;/h3&gt;            &lt;/template&gt;        &lt;/Suspense&gt;    &lt;/div&gt;&lt;/template&gt;</code></pre></li></ul></li></ul><h1 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h1><h2 id="1-全局API的转移"><a href="#1-全局API的转移" class="headerlink" title="1.全局API的转移"></a>1.全局API的转移</h2><ul><li><p>Vue 2.x 有许多全局 API 和配置。</p><ul><li><p>例如：注册全局组件、注册全局指令等。</p><pre><code class="js">//注册全局组件Vue.component(&#39;MyButton&#39;, &#123;  data: () =&gt; (&#123;    count: 0  &#125;),  template: &#39;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#39;&#125;)//注册全局指令Vue.directive(&#39;focus&#39;, &#123;  inserted: el =&gt; el.focus()&#125;</code></pre></li></ul></li><li><p>Vue3.0中对这些API做出了调整：</p><ul><li><p>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p><table><thead><tr><th>2.x 全局 API（<code>Vue</code>）</th><th>3.x 实例 API (<code>app</code>)</th></tr></thead><tbody><tr><td>Vue.config.xxxx</td><td>app.config.xxxx</td></tr><tr><td>Vue.config.productionTip</td><td><strong style="color:#DD5145">移除</strong></td></tr><tr><td>Vue.component</td><td>app.component</td></tr><tr><td>Vue.directive</td><td>app.directive</td></tr><tr><td>Vue.mixin</td><td>app.mixin</td></tr><tr><td>Vue.use</td><td>app.use</td></tr><tr><td>Vue.prototype</td><td>app.config.globalProperties</td></tr></tbody></table></li></ul></li></ul><h2 id="2-其他改变"><a href="#2-其他改变" class="headerlink" title="2.其他改变"></a>2.其他改变</h2><ul><li><p>data选项应始终被声明为一个函数。</p></li><li><p>过度类名的更改：</p><ul><li><p>Vue2.x写法</p><pre><code class="css">.v-enter,.v-leave-to &#123;  opacity: 0;&#125;.v-leave,.v-enter-to &#123;  opacity: 1;&#125;</code></pre></li><li><p>Vue3.x写法</p><pre><code class="css">.v-enter-from,.v-leave-to &#123;  opacity: 0;&#125;.v-leave-from,.v-enter-to &#123;  opacity: 1;&#125;</code></pre></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p></li><li><p><strong style="color:#DD5145">移除</strong><code>v-on.native</code>修饰符</p><ul><li><p>父组件中绑定事件</p><pre><code class="vue">&lt;my-component  v-on:close=&quot;handleComponentEvent&quot;  v-on:click=&quot;handleNativeClickEvent&quot;/&gt;</code></pre></li><li><p>子组件中声明自定义事件</p><pre><code class="vue">&lt;script&gt;  export default &#123;    emits: [&#39;close&#39;]  &#125;&lt;/script&gt;</code></pre></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>过滤器（filter）</p><blockquote><p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p></blockquote></li><li><p>……</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于mirai搭建QQ机器人的一些问题</title>
      <link href="/2023/07/22/mirai/"/>
      <url>/2023/07/22/mirai/</url>
      
        <content type="html"><![CDATA[<blockquote><p>可参考文档<a href="https://www.bilibili.com/read/cv18489742?from=articleDetail">【QQ机器人】给纯新手的通俗易懂安装教程，长期接受评论私信答疑[基于mirai]</a></p></blockquote><h1 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h1><h2 id="文件夹的内容介绍"><a href="#文件夹的内容介绍" class="headerlink" title="文件夹的内容介绍"></a>文件夹的内容介绍</h2><p><img src="/./img/mirai/mcl.png"></p><h2 id="自动登录的设置"><a href="#自动登录的设置" class="headerlink" title="自动登录的设置"></a>自动登录的设置</h2><p>打开路径：<br> <code>config\Console\AutoLogin.yml</code><br>填写信息<br><img src="/./img/mirai/AutoLogin.png"></p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><ol><li>先将自动登录的设置关掉</li><li>打开 <strong>mcl.cmd</strong> 输入</li></ol><pre><code>mclx update </code></pre><h1 id="登陆失败或者提示版本过低的解决方法"><a href="#登陆失败或者提示版本过低的解决方法" class="headerlink" title="登陆失败或者提示版本过低的解决方法"></a>登陆失败或者提示版本过低的解决方法</h1><blockquote><p>请先参考官方论坛 <a href="https://mirai.mamoe.net/topic/223/%E6%97%A0%E6%B3%95%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%B4%E6%97%B6%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88">无法登录的临时处理方案</a></p></blockquote><h2 id="2023-x2F-7-x2F-22"><a href="#2023-x2F-7-x2F-22" class="headerlink" title="2023&#x2F;7&#x2F;22"></a>2023&#x2F;7&#x2F;22</h2><ul><li>更新 <strong>协议修复插件</strong>  <a href="https://github.com/cssxsh/fix-protocol-version">fix-protocol-version</a> 至 1.9.8</li><li>需要第三方服务，我选择的是 <strong>unidbg-fetch-qsign 1.1.6</strong></li></ul><ol><li>下载 <a href="https://github.com/fuqiuluo/unidbg-fetch-qsign/releases">地址</a></li><li>解压到机器人目录下<blockquote><p>注意：<strong>txlib</strong>文件夹里有此第三方协议包含的支持的协议版本。此处的<em>8.6.93、8.9.68和8.9.70</em>其实是qq的三个版本号。如果以后登录需要其他的版本就需要更新。</p></blockquote></li><li>执行一次在线同步协议指令<br><code> /protocol sync ANDROID_PHONE</code><br><code> /protocol sync ANDROID_PAD</code><br><img src="/./img/mirai/protocol.png" alt="出现错误"></li></ol><h2 id="2023-x2F-4-x2F-18"><a href="#2023-x2F-4-x2F-18" class="headerlink" title="2023&#x2F;4&#x2F;18"></a>2023&#x2F;4&#x2F;18</h2><ul><li>plugins 新增 fix-protocol-version</li><li>config&#x2F;console&#x2F;autologin 修改协议：<br> <code>      protocol: MACOS </code></li></ul>]]></content>
      
      
      <categories>
          
          <category> QQ机器人 </category>
          
          <category> Mirai </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mirai </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC技术学习（二）</title>
      <link href="/2023/07/11/JDBC2/"/>
      <url>/2023/07/11/JDBC2/</url>
      
        <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><ul><li>开发工具：idea — 2019.1</li><li>jdk：</li><li>MySQL-jdbc驱动：5.0.x  ( com.mysql.jdbc.Driver )</li><li>druid：1.1.21</li><li>MySQL：5.5</li></ul><h1 id="在Java工程中导入-mysql-jdbc-驱动-jar-包"><a href="#在Java工程中导入-mysql-jdbc-驱动-jar-包" class="headerlink" title="在Java工程中导入 mysql-jdbc 驱动 jar 包"></a>在Java工程中导入 mysql-jdbc 驱动 jar 包</h1><h2 id="对应版本的jar包选择"><a href="#对应版本的jar包选择" class="headerlink" title="对应版本的jar包选择"></a>对应版本的jar包选择</h2><p><img src="/./img/jdbc/jar.png"></p><h2 id="导入依赖的步骤"><a href="#导入依赖的步骤" class="headerlink" title="导入依赖的步骤"></a>导入依赖的步骤</h2><ol><li>在程序中创建一个 <strong>lib</strong> 的文件夹</li><li>将 jar 包 和 jar 包的源码（ zip ）粘贴到上述文件夹下</li><li>右键 jar 包，点击 <em>Add as Library</em> ，点击 ok 完成导入</li><li>若 jar 包前面有个三角能展开，说明导入成功</li></ol><h2 id="JDBC-基本使用步骤分析"><a href="#JDBC-基本使用步骤分析" class="headerlink" title="JDBC 基本使用步骤分析"></a>JDBC 基本使用步骤分析</h2><ol><li>注册驱动 — 把依赖的 jar 包进行安装</li><li>建立连接 — Connection</li><li>创建发送 SQL 语句的对象 — statement</li><li>statement 对象发送 SQL 语句到数据库并且获取返回结果</li><li>解析结果集 — 结果对象 resultset</li><li>销毁资源 — 释放 Connection 、statement 、resultset<br><img src="/./img/jdbc/jdbc%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4.png"></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JDBC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM框架及整合</title>
      <link href="/2023/06/18/SSM%E6%A1%86%E6%9E%B6%E5%8F%8A%E6%95%B4%E5%90%88/"/>
      <url>/2023/06/18/SSM%E6%A1%86%E6%9E%B6%E5%8F%8A%E6%95%B4%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><p>封装JDBC，负责访问数据库，完成持久化操作。</p><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>使用其核心思想IOC管理组件，使用AOP思想实现功能增强。</p><h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><p>接受浏览器发送的请求，并响应浏览器数据。</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>Java SE 和 web 基础知识</p>]]></content>
      
      
      <categories>
          
          <category> SSM框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis</title>
      <link href="/2023/06/18/MyBatis/"/>
      <url>/2023/06/18/MyBatis/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> SSM框架 </category>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC技术学习（一）</title>
      <link href="/2023/06/13/JDBC1/"/>
      <url>/2023/06/13/JDBC1/</url>
      
        <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><ul><li>开发工具：idea — 2019.1</li><li>jdk：</li><li>MySQL-jdbc驱动：5.0.x  ( com.mysql.jdbc.Driver )</li><li>druid：1.1.21</li><li>MySQL：5.5</li></ul><h1 id="一、技术概述"><a href="#一、技术概述" class="headerlink" title="一、技术概述"></a>一、技术概述</h1><blockquote><p>JDBC: Java Database Connectivity — Java连接数据库技术统称！</p></blockquote><p>在Java代码中，使用JDBC提供的方法，可以发送字符串类型的SQL语句到数据库管理软件（MySQL,Oracle等），并且获取语句执行结果，进而实现数据库数据CURD操作的技术。</p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><blockquote><p>jdbc技术是典型的 <strong>面向接口编程</strong></p></blockquote><p><img src="/./img/jdbc/3.png"></p><ul><li>Java提供的jdbc规范(接口) — 存储在 java.sql 和 javax.sql 包中的 api </li><li>各个数据库厂商的实现驱动 jar 包<blockquote><p> <strong>jar 包</strong> ：Java程序打成的一种压缩包格式，引入项目后，可以使用这个Java 程序中的类和方法以及属性。</p></blockquote></li></ul><p><img src="/./img/jdbc/4.png"></p><h2 id="Java代码步骤"><a href="#Java代码步骤" class="headerlink" title="Java代码步骤"></a>Java代码步骤</h2><ol><li>java.sql.*  JDBC接口 对象 &#x3D; 第三方实现类实例</li><li>对象 . jdbc标准方法 ( ) ;</li></ol><h1 id="二、核心-api-使用"><a href="#二、核心-api-使用" class="headerlink" title="二、核心 api 使用"></a>二、核心 <em>api</em> 使用</h1><blockquote><p><em>API（Application Programming Interface,应用程序编程接口）</em>是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。</p></blockquote><h2 id="API使用路线"><a href="#API使用路线" class="headerlink" title="API使用路线"></a>API使用路线</h2><p><img src="/./img/jdbc/api1.png" alt="API使用路线"></p><blockquote><p><strong>动态值</strong>：由外部传入的值</p></blockquote><h2 id="涉及的具体核心类和接口"><a href="#涉及的具体核心类和接口" class="headerlink" title="涉及的具体核心类和接口"></a>涉及的具体核心类和接口</h2><h3 id="1-DriverManager"><a href="#1-DriverManager" class="headerlink" title="1. DriverManager"></a>1. DriverManager</h3><ul><li>将第三方数据库厂商的实现驱动</li><li>可以根据数据库连接信息获取 connection</li></ul><h3 id="2-Connection"><a href="#2-Connection" class="headerlink" title="2. Connection"></a>2. Connection</h3><ul><li>和数据库建立的连接，在连接的对象上可以多次执行数据库 crud 动作</li><li>可以获取 statement 、preparedstatement 和 callablestatement 对象</li></ul><h3 id="3-statement-、preparedstatement、-callablestatement"><a href="#3-statement-、preparedstatement、-callablestatement" class="headerlink" title="3. statement 、preparedstatement、 callablestatement"></a>3. statement 、preparedstatement、 callablestatement</h3><ul><li>是具体发送 SQL 语句到数据库管理软件的对象</li><li>这三个对象发送不同的SQL语句</li><li><strong>preparedstatement</strong> 使用为重点</li></ul><h3 id="4-Result"><a href="#4-Result" class="headerlink" title="4. Result"></a>4. Result</h3><ul><li>面向对象思维的产物（抽象成数据库的查询结果表）</li><li>存储 DQL 查询数据库结果的对象</li><li>需要我们进行解析，获取具体的数据库数据</li><li>只有查询语句才有 result 对象，其他的都是 int 型</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JDBC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo文章管理</title>
      <link href="/2023/06/08/Hexo%E6%96%87%E7%AB%A0%E7%AE%A1%E7%90%86/"/>
      <url>/2023/06/08/Hexo%E6%96%87%E7%AB%A0%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>本篇文章是用来记录写文章的一些基础操作，以免忘记。0.0</p><h1 id="一-新建-md-文件"><a href="#一-新建-md-文件" class="headerlink" title="一. 新建 md 文件"></a>一. 新建 md 文件</h1><p><code>hexo new [layout] &quot;&lt;title&gt;&quot;</code><br>如<br><code>hexo new post &quot;Hexo文章管理&quot;</code> </p><h2 id="布局-–-layout"><a href="#布局-–-layout" class="headerlink" title="布局 – [layout]"></a>布局 – [layout]</h2><p>新建的时候，会根据 <em>scaffolds</em> 文件夹内相对应的文件模板来建立。<br><img src="/./img/scaffolds.png" alt="scaffolds"></p><h3 id="1-post（文章）"><a href="#1-post（文章）" class="headerlink" title="1. post（文章）"></a>1. post（文章）</h3><p>如果没有指定布局类型，则为默认布局为<em>post</em>，可以在站点配置文件修改 <em>default_layout</em> 参数来修改默认布局。</p><h3 id="2-draft（草稿）"><a href="#2-draft（草稿）" class="headerlink" title="2. draft（草稿）"></a>2. draft（草稿）</h3><ul><li>在建立时会被保存到 <em>source&#x2F;_drafts</em> 文件夹中</li><li>不会显示在页面上，如果不想某一篇文章显示在页面上，那么就可以把它移动到 <em>_drafts</em>文件夹中</li><li>在启动服务器时加上 <em>–draft</em> 参数来查看草稿<br><code>hexo server --draft</code></li><li>可以在站点配置文件中把 <em>render_drafts</em> 参数设为 true 来预览草稿 </li><li>通过 <em>publish</em> 命令将草稿发布文章或者页面，它将会被移动到指定的文件夹<br><code>hexo publish [layout] &lt;title&gt;</code></li></ul><h3 id="3-page（页面）"><a href="#3-page（页面）" class="headerlink" title="3. page（页面）"></a>3. page（页面）</h3><p>即独立页面，创建一个以标题为名字的目录，并在目录中放置一个 <em>index.md</em>文件，主要用来DIY博客页面的。<br><img src="/./img/page.png" alt="page"></p><hr><h1 id="二-设置Front-matter"><a href="#二-设置Front-matter" class="headerlink" title="二. 设置Front-matter"></a>二. 设置Front-matter</h1><p>创建好 md 文件后，最上方<strong>自动生成以 “- - - ”分隔</strong>的区域，主要是根据 <em>scaffolds</em> 文件夹中的模板生成的，这个区域用于指定个别文件的变量。<br><img src="/./img/Front-matter.png" alt="Markdown语言学习页面的Front-matter"></p><h2 id="预定义参数"><a href="#预定义参数" class="headerlink" title="预定义参数"></a>预定义参数</h2><table><thead><tr><th align="center">参数</th><th align="center">解释</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">layout</td><td align="center">布局</td><td align="center">默认为true，如果你不想你的文章被处理，可以设置为false</td></tr><tr><td align="center">tags</td><td align="center">标签</td><td align="center">不适用于页面page布局</td></tr><tr><td align="center">categories</td><td align="center">分类</td><td align="center">不适用于页面page布局</td></tr><tr><td align="center">cover</td><td align="center">预览图</td><td align="center">top_img没设置的话，则默认顶部图片为cover</td></tr><tr><td align="center">top_img</td><td align="center">顶部图片</td><td align="center">该页面的顶部图片</td></tr></tbody></table><h3 id="1-标签tags"><a href="#1-标签tags" class="headerlink" title="1. 标签tags"></a>1. 标签tags</h3><p>一篇文章可以设置多个标签。例如：</p><pre><code> tags:  - Hexo - 博客 </code></pre><h3 id="2-分类categories"><a href="#2-分类categories" class="headerlink" title="2. 分类categories"></a>2. 分类categories</h3><ul><li>分类有层级关系</li></ul><pre><code>categories:- 第一层级- 第二层级</code></pre><p>即“第二层级” 是 “第一层级” 的子分类。</p><ul><li>添加多个分类</li></ul><pre><code>categories:- [1, 1.1]- [1, 1.2]- [2] </code></pre><ol><li>1和2 是同分类</li><li>1.1和1.2 是1下的同级子分类</li></ol><hr><h1 id="三-hexo命令"><a href="#三-hexo命令" class="headerlink" title="三. hexo命令"></a>三. hexo命令</h1><p>一般发布文章或者修改博客后需要这些操作：<strong>清除缓存&gt;生成静态文件&gt;启动服务器</strong>，测试没问题后再部署。</p><ul><li>清除缓存：<code>hexo clean</code></li><li>生成静态文件：<code>hexo generate</code>可简写为 <code>hexo g</code></li><li>启动服务器：<code>hexo server</code>或者 <code>hexo s</code><br> 常用参数：<code>-p（--port）</code>重设端口</li><li>部署：<code>hexo deploy</code>可简写为<code>hexo d</code>，用于将网站部署到服务器上<br>常用参数：<code>-g（--generate）</code><br><code>hexo d -g</code> 部署前预先生成静态文件，等同于 <code>hexo g -d</code></li></ul><p>可写成一条命令</p><pre><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo shexo d </code></pre>]]></content>
      
      
      <categories>
          
          <category> 博客基础 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语言学习（二）</title>
      <link href="/2023/06/07/Markdown%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2023/06/07/Markdown%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><a id="article_top"></a>本篇是记录md语言中的一些进阶的写法。</p><h1 id="锚点跳转"><a href="#锚点跳转" class="headerlink" title="锚点跳转"></a>锚点跳转</h1><ul><li>word文档的文档跳转，在md中也可以使用</li><li>md的锚点跳转是使用html的标签跳转</li></ul><pre><code class="html">&lt;a id=&quot;article_top&quot;&gt;&lt;/a&gt;[回到开头](#article_top)</code></pre><p>例如<a href="#article_top">回到开头</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客基础 </category>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语言学习（一）</title>
      <link href="/2023/05/28/Markdown%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/05/28/Markdown%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Markdown 是一种用来写作的轻量级「标记语言」，它用简洁的语法代替排版。</p></blockquote><p>我将参考Markdown 的<a href="https://daringfireball.net/projects/markdown/syntax">官方文档</a>和<a href="https://sspai.com/post/25137">认识与入门 Markdown</a>来进行学习，在<a href="https://www.jianshu.com/">简书</a>上进行文章的实时预览。</p><h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p> <code> #  一级标题</code><br><code> ## 二级标题</code><br><code>### 三级标题 </code><br>以此类推，总共六级标题，建议在井号后加一个空格，这是最标准的 Markdown 语法。</p><h1 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h1><p>列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加 1.2.3. 符号要和文字之间加上一个字符的空格。</p><hr><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>只需要在文本前加入 &gt; 这种尖括号（大于号）即可。</p><hr><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p>  <code>![文字](图片的url地址)</code> </p><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p> <code>[文字](url地址)</code></p><hr><h1 id="字体的效果"><a href="#字体的效果" class="headerlink" title="字体的效果"></a>字体的效果</h1><ul><li>粗体：两个 * 或 _ 包含一段文本</li><li>斜体：一个 * 或 _ 包含一段文本</li><li>标记文本（高光）：两个&#x3D;&#x3D;包含一段文本</li><li>删除文本：两个 ~~ 包含一段文本</li></ul><hr><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p> <code>| Tables      | Are           | Cool |</code><br><code>| ------------- |:-------------:| ------:|</code><br> <code>| col 3 is     | right-aligned | $1600 |</code><br>这段代码实际效果如下：</p><table><thead><tr><th>Tables</th><th align="center">Are</th><th align="right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td align="center">right-aligned</td><td align="right">$1600</td></tr></tbody></table><ul><li>对齐<br>:— 表示左对齐，:—: 表示居中，—:表示右对齐。</li><li>换行<br>在表格内换行，可以使用 html 的 br 标签。<br><code>&lt;br&gt;</code></li></ul><hr><h1 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h1><ul><li>一句：用两个“ &#96; ”把中间的代码包裹起来</li><li>一段：“ &#96;&#96;&#96; ”</li></ul><pre><code>\````代码类型代码块\```` </code></pre><ul><li>使用 tab 键缩进</li><li>被md语法解析了的特殊字符，可在前面加 “ &#x2F; ”</li></ul><hr><h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><p>分割线的语法只需要另起一行，连续输入三个星号 *** 即可。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 博客基础 </category>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
